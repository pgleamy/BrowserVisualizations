<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PuLsE v.11</title>
  <!-- Three.js r154 Import Map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/"
    }
  }
  </script>

  <style>
    /* CSS */
    body.hide-cursor { cursor: none; }
    body, html {
      margin: 0; padding: 0; overflow: hidden;
      background-color: #000; font-family: sans-serif;
      transition: opacity 0.3s ease;
    }
    canvas { display: block; }
    /* Control Panel styling */
    #controlPanel {
      position: fixed; top: 0; left: 0; width: 250px; max-height: 100%;
      background: rgba(50, 50, 50, 0); color: #fff; overflow-y: auto;
      transition: opacity 0.3s ease, transform 0.3s ease;
      transform: translateX(-150px); opacity: 0; z-index: 10;
      padding: 5px; box-sizing: border-box;
    }
    #controlPanel:hover { transform: translateX(0); opacity: 1; }
    .moduleHeader {
      background: #333; padding: 6px 3px; margin: 3px 0;
      cursor: pointer; font-size: 11px;
      display: flex; justify-content: space-between; align-items: center;
    }
    .moduleContent {
      display: none; padding: 3px; background: #444; margin-bottom: 3px; font-size: 10px;
    }
    .controlElement { margin: 4px 0; }
    .controlElement label { display: flex; margin-bottom: 2px; }
    /* Favorite Settings styles */
    #favoriteSettingsSection { border-top: 1px solid #666; padding-top: 4px; margin-top: 5px; }
    /* New Favorites dropdown styling */
    #toggleFavoriteList {
      width: 100%;
      background: #555;
      color: #fff;
      padding: 4px 8px;
      margin: 4px 0;
      font-size: 11px;
      border: none;
      cursor: pointer;
    }
    #favoriteListContainer {
      overflow: hidden;
      max-height: 0;
      transition: max-height 0.3s ease;
    }
    #favoriteListContainer.open {
      max-height: 500px; /* Adjust height as needed */
    }
    #favoriteList { list-style: none; padding: 0; margin: 0; }
    #favoriteList li {
      margin: 3px 0; display: flex; justify-content: space-between; align-items: center;
    }
    #favoriteList button { margin-left: 3px; font-size: 10px; padding: 2px 3px; }
    
    /* New Slideshow Controls styling */
    #slideshowControls {
      margin: 8px 0;
      padding: 4px;
      background: #444;
      border: 1px solid #666;
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      font-size: 11px;
    }
    #slideshowControls button {
      margin-bottom: 4px;
    }
    #slideshowOptions {
      display: flex;
      justify-content: space-between;
    }
    #slideshowOptions label {
      display: flex;
      align-items: center;
    }
  </style>
</head>
<body>
  <!-- Control Panel -->
  <div id="controlPanel">
    <!-- Global Settings Panel -->
    <div class="moduleHeader" data-target="globalSettings" style="position: relative; background: #2b2b2b;">
      <span>PuLsE Globals</span>
      <div id="donate-button-container" style="position: absolute; font-size: 10px; top: 2px; right: 2px; z-index: 100;">
        <div id="donate-button"></div>
        <!-- PayPal Donate SDK (kept as-is) -->
        <script src="https://www.paypalobjects.com/donate/sdk/donate-sdk.js" charset="UTF-8"></script>
        <script>
          PayPal.Donation.Button({
            env: 'production',
            hosted_button_id: 'KL9MTW9S89GFJ',
            image: {
              src: 'https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif',
              alt: 'Donate with PayPal button',
              title: 'PayPal - The safer, easier way to pay online!'
            }
          }).render('#donate-button');
        </script>
      </div>
    </div>
    <div id="globalSettings" class="moduleContent">
      <!-- Fullscreen Control -->
      <div class="controlElement">
        <label>
          <input type="checkbox" id="fullscreenToggle"> Fullscreen
        </label>
      </div>

      <!-- NEW: Single "Screen stays active" checkbox for wake lock functionality -->
      <div class="controlElement">
        <label>
          <input type="checkbox" id="screenStaysActive" />
          Screen stays active
        </label>
      </div>

      <div class="controlElement">
        <label>Number of Points:
          <input type="range" id="globalPointCount" min="10000" max="60000" step="100" value="30000">
        </label>
      </div>
      <div class="controlElement">
        <label>Disk Size:
          <input type="range" id="globalSphereSize" min="0.1" max="2.5" step="0.001" value="1">
        </label>
      </div>
      <div class="controlElement">
        <label>Global Speed:
          <input type="range" id="globalSpeed" min="0" max="3" step="0.001" value="1">
        </label>
      </div>
      <div class="controlElement">
        <label>Global Color (Hue):
          <input type="range" id="globalColor" min="0" max="360" step=".01" value="180">
        </label>
      </div>

      <!-- Glow Points Option -->
      <div class="controlElement">
        <label>
          <input type="checkbox" id="useGlowPoints" checked> Use Glow Points (instead of Spheres)
        </label>
      </div>

      <!-- Glow Points Settings Module -->
      <div class="moduleHeader" data-target="glowPointsSettings" id="glowPointsHeader" style="display: none;">
        <span>Glow Points Settings</span>
      </div>
      <div id="glowPointsSettings" class="moduleContent" style="display: none;">
        <div class="controlElement">
          <label>Stop 1 Position
            <input type="range" id="glowStop0Pos" min="0" max="1" step="0.01" value="0">
          </label>
        </div>
        <div class="controlElement">
          <label>Stop 1 Alpha
            <input type="range" id="glowStop0Alpha" min="0" max="1" step="0.01" value="1">
          </label>
        </div>
        <div class="controlElement">
          <label>Stop 2 Position
            <input type="range" id="glowStop1Pos" min="0" max="1" step="0.01" value="0.15">
          </label>
        </div>
        <div class="controlElement">
          <label>Stop 2 Alpha
            <input type="range" id="glowStop1Alpha" min="0" max="1" step="0.01" value="1">
          </label>
        </div>
        <div class="controlElement">
          <label>Stop 3 Position
            <input type="range" id="glowStop2Pos" min="0" max="1" step="0.01" value="0.25">
          </label>
        </div>
        <div class="controlElement">
          <label>Stop 3 Alpha
            <input type="range" id="glowStop2Alpha" min="0" max="1" step="0.01" value="0.4">
          </label>
        </div>
        <div class="controlElement">
          <label>Stop 4 Position
            <input type="range" id="glowStop3Pos" min="0" max="1" step="0.01" value="1">
          </label>
        </div>
        <div class="controlElement">
          <label>Stop 4 Alpha
            <input type="range" id="glowStop3Alpha" min="0" max="1" step="0.01" value="0">
          </label>
        </div>
      </div>
      <!-- End Glow Points Settings -->

      <!-- New Slideshow Controls Section -->
      <div id="slideshowControls">
        <button id="startSlideshow">SLIDESHOW</button>
        <div id="slideshowOptions">
          <label for="slideshowRandom">
            <input type="checkbox" id="slideshowRandom"> Random
          </label>
          <label for="slideshowInterval">
            Interval: <input type="number" id="slideshowInterval" min="1" max="30" value="5" style="width:40px;"> min
          </label>
        </div>
<div id="slideshowInstructions" style="font-size:10px; text-align:center; margin-top:4px;">
  Move your mouse to right side to disable
</div>
      </div>

<div id="favoriteSettingsSection">
  <button id="saveFavorite">Save Favorite</button>
  <button id="toggleFavoriteList">Your Favorites</button>
  <button id="exportFavorites">Export Favorites</button>
  <span id="exportStatusText" style="font-size:6.5px; margin-left:2px;"></span>
  <button id="importFavorites">Import Favorites</button>
  <span id="importStatusText" style="font-size:6.5px; margin-left:2px;"></span>
  <input type="file" id="importFavoritesInput" accept="application/json" style="display:none;">
  <div id="favoriteListContainer">
    <ul id="favoriteList"></ul>
  </div>
</div>

    </div>

    <!-- Sound Module Panel -->
    <div class="moduleHeader" data-target="soundModule" style="background: #2b2b2b;">Sound Module</div>
    <div id="soundModule" class="moduleContent">
      <div class="controlElement">
        <label>
          <input type="checkbox" id="soundEnable" checked> Enable Sound Input
        </label>
      </div>
      <div class="controlElement">
        <label>Sensitivity:
          <input type="range" id="soundSensitivity" min="0.0" max="0.6" step="0.001" value="0.0">
        </label>
      </div>
      <!-- Existing Sound Module Controls -->
      <div class="controlElement">
        <label>
          <input type="checkbox" id="soundEffectEmissive" checked> Emissive Intensity Modulation
        </label>
      </div>
      <div class="controlElement">
        <label>
          <input type="checkbox" id="soundEffectScale" checked> Disk Scale Expansion
        </label>
      </div>
      <div class="controlElement">
        <label>Expansion Factor:
          <input type="range" id="soundExpansionFactor" min="0" max="15" step="0.001" value="2">
        </label>
      </div>
      <!-- Jitter Modulation Controls -->
      <div class="controlElement">
        <label>
          <input type="checkbox" id="soundJitterEnable" checked> Jitter (*enables Rossler)
        </label>
      </div>
      <div class="controlElement">
        <label>Jitter Low Range (50 - 160):
          <input type="range" id="soundJitterLow" min="50" max="160" step="0.0001" value="100">
        </label>
      </div>
      <div class="controlElement">
        <label>Jitter High Range (161 - 260):
          <input type="range" id="soundJitterHigh" min="161" max="260" step="0.001" value="">
        </label>
      </div>
      <div class="controlElement">
        <label>Jitter Modulation Strength (0 - 2):
          <input type="range" id="soundJitterModStrength" min="0" max="2" step="0.0001" value=".5">
        </label>
      </div>
      <div class="controlElement" id="soundStatus" style="font-size:11px; text-align:center;">
        Click "Start Audio" to begin.
      </div>
      <div class="controlElement" style="text-align:center;">
        <button id="startAudio" style="padding:4px 8px; font-size:11px;">Start Audio</button>
      </div>
    </div>

    <!-- Equation Modules Container -->
    

<!-- Equation Categories Container -->
<div id="eqModules">
  <div id="pathsCategory">
    <div class="moduleHeader" data-target="pathsContent">Paths</div>
    <div id="pathsContent" class="moduleContent"></div>
  </div>
  <div id="distortionsCategory">
    <div class="moduleHeader" data-target="distortionsContent">Distortions</div>
    <div id="distortionsContent" class="moduleContent"></div>
  </div>
  <div id="noisesCategory">
    <div class="moduleHeader" data-target="noisesContent">Noises</div>
    <div id="noisesContent" class="moduleContent"></div>
  </div>
</div>

  </div>

  <!-- Three.js r154 Code -->
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // Global variable for global speed (used by some equations)
    let GLOBAL_SPEED = 1.0;
    // Global frequency data is stored on the SoundModule instance.
    window.soundMod = null;
    window.soundModBass = 0;
    window.soundModMid = 0;
    window.soundModHigh = 0;

    /**************** Utility Functions ****************/
    function hexToRgb(hex) {
      const bigint = parseInt(hex.replace('#',''), 16);
      return { r: ((bigint >> 16) & 255)/255, g: ((bigint >> 8) & 255)/255, b: (bigint & 255)/255 };
    }
    function hslToRgb(h, s, l) {
      h /= 360;
      let r, g, b;
      if(s === 0){
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if(t < 0) t += 1;
          if(t > 1) t -= 1;
          if(t < 1/6) return p + (q - p) * 6 * t;
          if(t < 1/2) return q;
          if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l*(1+s) : l+s-l*s;
        const p = 2*l - q;
        r = hue2rgb(p, q, h+1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h-1/3);
      }
      return { r, g, b };
    }

    /**************** Global Constant ****************/
    const DEFAULT_POINT_COUNT = 30000;

    /**************** Equation Classes ****************/
    class EquationBase {
      constructor(){
        this.enabled = true;
        this.speed = 1.0;
        this.baseColor = "#ffffff";
        this.pointCount = DEFAULT_POINT_COUNT;
      }
      getContribution(index, totalPoints, time){
        return new THREE.Vector3(0, 0, 0);
      }
      setParameters(params){
        if(params.speed !== undefined) this.speed = params.speed;
        if(params.baseColor !== undefined) this.baseColor = params.baseColor;
      }
      setPointCount(n){ this.pointCount = n; }
      calculateColorPalette(baseHex){ return [baseHex]; }
      // ADDED: Serialization methods for internal state
      serializeState() { return {}; }
      deserializeState(state) { }
    }

    class LissajousEquation extends EquationBase {
      constructor(){
        super();
        this.A = 50; 
        this.B = 50; 
        this.a = 3; 
        this.b = 2; 
        this.delta = Math.PI/2;
        this.t = 0;
      }
      getContribution(index, totalPoints, time){
        this.t = time * this.speed;
        const tVal = this.t + (index/totalPoints)*Math.PI*2;
        const x = this.A * Math.sin(this.a*tVal + this.delta);
        const y = this.B * Math.sin(this.b*tVal);
        const z = 20 * Math.cos(tVal);
        return new THREE.Vector3(x, y, z);
      }
    }

    class RoseCurveEquation extends EquationBase {
      constructor(){
        super();
        this.A = 70; 
        this.k = 4;
        this.t = 0;
      }
      getContribution(index, totalPoints, time){
        this.t = time * this.speed;
        const theta = (index/totalPoints)*Math.PI*2;
        const r = this.A * Math.cos(this.k*theta + this.t);
        return new THREE.Vector3(
          r*Math.cos(theta),
          r*Math.sin(theta),
          10*Math.sin(3*theta+this.t)
        );
      }
    }

    class SpiralEquation extends EquationBase {
      constructor(){
        super();
        this.a = 5; 
        this.b = 4;
        this.t = 0;
      }
      getContribution(index, totalPoints, time){
        this.t = time * this.speed;
        const theta = (index/totalPoints)*Math.PI*8;
        const r = this.a + this.b*theta;
        return new THREE.Vector3(
          r*Math.cos(theta+this.t),
          r*Math.sin(theta+this.t),
          10*Math.sin(theta/3+this.t)
        );
      }
    }

    class FourierSeriesEquation extends EquationBase {
      constructor(){
        super();
        this.numTerms = 10; 
        this.baseAmp = 20;
        this.A = []; 
        this.phases = [];
        for(let n = 1; n <= this.numTerms; n++){
          this.A.push(this.baseAmp/n);
          this.phases.push(Math.random()*Math.PI*2);
        }
        this.t = 0;
      }
      getContribution(index, totalPoints, time){
        this.t = time * this.speed;
        const tVal = this.t + (index/totalPoints)*Math.PI*2;
        let x = 0, y = 0;
        for(let n = 1; n <= this.numTerms; n++){
          x += this.A[n-1]*Math.cos(n*tVal+this.phases[n-1]);
          y += this.A[n-1]*Math.sin(n*tVal+this.phases[n-1]);
        }
        return new THREE.Vector3(x, y, 10*Math.sin(2*tVal));
      }
    }

    class SHMEquation extends EquationBase {
      constructor(){
        super();
        this.A = 50; 
        this.omega = 2; 
        this.phi = 0;
        this.t = 0;
      }
      getContribution(index, totalPoints, time){
        this.t = time * this.speed;
        const tVal = this.t + (index/totalPoints)*Math.PI*2;
        return new THREE.Vector3(
          this.A*Math.cos(this.omega*tVal+this.phi),
          this.A*Math.sin(this.omega*tVal+this.phi),
          10*Math.sin(this.omega*tVal)
        );
      }
    }

    class LorenzAttractorEquation extends EquationBase {
      constructor(){
        super();
        this.sigma = 10; 
        this.rho = 28; 
        this.beta = 8/3;
        this.x = 0.1; 
        this.y = 0; 
        this.z = 0;
      }
      getContribution(index, totalPoints, time){
        const dt = 0.01*this.speed;
        const dx = this.sigma*(this.y-this.x);
        const dy = this.x*(this.rho-this.z)-this.y;
        const dz = this.x*this.y - this.beta*this.z;
        this.x += dx*dt;
        this.y += dy*dt;
        this.z += dz*dt;
        return new THREE.Vector3(this.x, this.y, this.z);
      }
      // ADDED: Save and restore internal state for Lorenz
      serializeState() {
        return { x: this.x, y: this.y, z: this.z };
      }
      deserializeState(state) {
        if(state){
          this.x = state.x;
          this.y = state.y;
          this.z = state.z;
        }
      }
    }

    class ReactionDiffusionEquation extends EquationBase {
      constructor(){
        super();
        this.gridSize = 50; 
        this.Du = 0.16; 
        this.Dv = 0.08;
        this.F = 0.035; 
        this.k = 0.065;
        this.u = []; 
        this.v = [];
        for(let i = 0; i < this.gridSize; i++){
          this.u[i] = []; 
          this.v[i] = [];
          for(let j = 0; j < this.gridSize; j++){
            this.u[i][j] = 1; 
            this.v[i][j] = 0;
          }
        }
        const mid = Math.floor(this.gridSize/2);
        this.u[mid][mid] = 0.50; 
        this.v[mid][mid] = 0.25;
      }
      getContribution(index, totalPoints, time){
        const i = Math.floor(index/this.gridSize);
        const j = index % this.gridSize;
        return new THREE.Vector3(
          i - this.gridSize/2,
          j - this.gridSize/2,
          this.u[i][j]*50
        );
      }
      update(deltaTime, time){
        const dt = deltaTime*this.speed;
        const newU = [], newV = [];
        for(let i = 0; i < this.gridSize; i++){
          newU[i] = []; newV[i] = [];
          for(let j = 0; j < this.gridSize; j++){
            newU[i][j] = this.u[i][j];
            newV[i][j] = this.v[i][j];
          }
        }
        for(let i = 1; i < this.gridSize-1; i++){
          for(let j = 1; j < this.gridSize-1; j++){
            const lapU = this.u[i-1][j] + this.u[i+1][j] + this.u[i][j-1] + this.u[i][j+1] - 4*this.u[i][j];
            const lapV = this.v[i-1][j] + this.v[i+1][j] + this.v[i][j-1] + this.v[i][j+1] - 4*this.v[i][j];
            const du = this.Du*lapU - this.u[i][j]*this.v[i][j]*this.v[i][j] + this.F*(1-this.u[i][j]);
            const dv = this.Dv*lapV + this.u[i][j]*this.v[i][j]*this.v[i][j] - (this.F+this.k)*this.v[i][j];
            newU[i][j] = this.u[i][j] + du*dt;
            newV[i][j] = this.v[i][j] + dv*dt;
          }
        }
        this.u = newU; 
        this.v = newV;
      }
      // ADDED: Serialization for Reaction-Diffusion state
      serializeState() {
        return { u: this.u, v: this.v };
      }
      deserializeState(state) {
        if(state && state.u && state.v){
          this.u = state.u;
          this.v = state.v;
        }
      }
    }

    class SimplexNoise {
      constructor(seed = Math.random()){
        this.seed = seed;
      }
      noise(x,y,z){
        return (Math.sin(x*12.9898 + y*78.233 + z*37.719 + this.seed*43758.5453)) % 1;
      }
    }

    class NoiseEquation extends EquationBase {
      constructor(){
        super();
        this.scaleFactor = 100; 
        this.t = 0;
        this.simplex = new SimplexNoise();
        this.setPointCount(this.pointCount);
      }
      getContribution(index, totalPoints, time){
        this.t = time*this.speed;
        const tVal = this.t + index*0.01;
        const n = this.simplex.noise(tVal, tVal, tVal);
        return new THREE.Vector3(
          this.scaleFactor*n*Math.cos(tVal),
          this.scaleFactor*n*Math.sin(tVal),
          50*n
        );
      }
      update(deltaTime, time){ }
    }

    // Fractal & Ridged Noise
    class FractalNoiseEquation extends EquationBase {
      constructor() {
        super();
        this.scaleFactor = 100;
        this.octaves = 4;
        this.persistence = 0.5;
        this.simplex = new SimplexNoise();
        this.t = 0;
      }
      getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const tVal = this.t + index * 0.01;
        let noiseValue = 0;
        let amplitude = 1.0;
        let frequency = 1.0;
        let maxAmplitude = 0;
        for (let i = 0; i < this.octaves; i++) {
          noiseValue += amplitude * this.simplex.noise(tVal * frequency, tVal * frequency, tVal * frequency);
          maxAmplitude += amplitude;
          amplitude *= this.persistence;
          frequency *= 2.0;
        }
        noiseValue /= maxAmplitude;
        return new THREE.Vector3(
          this.scaleFactor * noiseValue * Math.cos(tVal),
          this.scaleFactor * noiseValue * Math.sin(tVal),
          50 * noiseValue
        );
      }
      update(deltaTime, time) { }
    }

    class RidgedNoiseEquation extends EquationBase {
      constructor() {
        super();
        this.scaleFactor = 100;
        this.simplex = new SimplexNoise();
        this.t = 0;
      }
      getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const tVal = this.t + index * 0.01;
        let n = this.simplex.noise(tVal, tVal, tVal);
        const ridged = 1.0 - Math.abs(n);
        return new THREE.Vector3(
          this.scaleFactor * ridged * Math.cos(tVal),
          this.scaleFactor * ridged * Math.sin(tVal),
          50 * ridged
        );
      }
      update(deltaTime, time) { }
    }

    /************************************
     * NEW EQUATION CLASSES (from snippet)
     ************************************/
    class SineDistortionEquation extends EquationBase {
      constructor() {
        super();
        this.offsetX = 0;
        this.offsetY = -100;
        this.kDiv = 8;
        this.kSub = 12;
        this.scaleFactor = 0.7;
        this.xAmplitude = 20;
        this.yAmplitude = 20;
      }
      getContribution(index, totalPoints, time) {
        const dimension = Math.floor(Math.sqrt(this.pointCount));
        const row = Math.floor(index / dimension);
        const col = index % dimension;
        let px = col - dimension/2 + this.offsetX;
        let py = row - dimension/2 + this.offsetY;
        let pz = 0;
        const tVal = time * this.speed;
        const k = px / this.kDiv - this.kSub;
        const e = py / this.kDiv - this.kSub;
        px += Math.sin(k + tVal) * this.xAmplitude;
        py += Math.cos(e + tVal) * this.yAmplitude;
        px *= this.scaleFactor;
        py *= this.scaleFactor;
        return new THREE.Vector3(px, py, pz);
      }
    }

    class PhaseRippleEquation extends EquationBase {
      constructor() {
        super();
        this.phaseFactor = 0.1;
        this.xAmplitude = 20;
        this.yAmplitude = 20;
      }
      getContribution(index, totalPoints, time) {
        const dimension = Math.floor(Math.sqrt(this.pointCount));
        const row = Math.floor(index / dimension);
        const col = index % dimension;
        let px = col - dimension/2;
        let py = row - dimension/2;
        let pz = 0;
        const tVal = time * this.speed;
        const phase = Math.sin((px / 10) + (py / 10) * this.phaseFactor + tVal);
        px += phase * this.xAmplitude;
        py += phase * this.yAmplitude;
        return new THREE.Vector3(px, py, pz);
      }
    }

    class ZSineWarpEquation extends EquationBase {
      constructor() {
        super();
        this.zAmplitude = 30;
        this.frequency = 0.5;
      }
      getContribution(index, totalPoints, time) {
        const dimension = Math.floor(Math.sqrt(this.pointCount));
        const row = Math.floor(index / dimension);
        const col = index % dimension;
        let px = col - dimension/2;
        let py = row - dimension/2;
        const tVal = time * this.speed;
        const pz = Math.sin(tVal * this.frequency + (px * py) / 10000) * this.zAmplitude;
        return new THREE.Vector3(px, py, pz);
      }
    }

    class RadialTwistEquation extends EquationBase {
      constructor() {
        super();
        this.radialFactor = 0.5;
        this.twistFactor = 2;
        this.zWaveFrequency = 0.3;
        this.zWaveAmplitude = 20;
      }
      getContribution(index, totalPoints, time) {
        const dimension = Math.floor(Math.sqrt(this.pointCount));
        const row = Math.floor(index / dimension);
        const col = index % dimension;
        let px = col - dimension/2;
        let py = row - dimension/2;
        let pz = 0;
        const tVal = time * this.speed;
        // const radius = Math.sqrt(px + py*py);
        const radius = Math.sqrt(Math.abs(px + py*py)); // replaced above to avoid NaN error
        const angle = Math.atan2(py, px) + this.twistFactor * radius + tVal * this.radialFactor;
        const oldPx = px;
        const oldPy = py;
        px += radius * Math.cos(angle) - oldPx;
        py += radius * Math.sin(angle) - oldPy;
        pz += Math.sin(radius * this.zWaveFrequency + tVal) * this.zWaveAmplitude;
        return new THREE.Vector3(px, py, pz);
      }
    }

    class TorusEquation extends EquationBase {
      constructor(){
        super(); 
        this.R = 50; 
        this.r = 20; 
        this.t = 0;
      }
      getContribution(index, totalPoints, time){
        this.t = time*this.speed;
        const u = (index/totalPoints)*Math.PI*2;
        const v = this.t + (index/totalPoints)*Math.PI*2;
        return new THREE.Vector3(
          (this.R+this.r*Math.cos(v))*Math.cos(u),
          (this.R+this.r*Math.cos(v))*Math.sin(u),
          this.r*Math.sin(v)
        );
      }
    }

    class RosslerEquation extends EquationBase {
      constructor(){
        super();
        this.a = 0.2; 
        this.b = 0.2; 
        this.c = 5.7;
        this.x = 0.1; 
        this.y = 0; 
        this.z = 0;
        this.jitterFactor = 0.05;
      }
      getContribution(index, totalPoints, time, deltaTime){
        const dt = (deltaTime || 0.016) * this.speed;
        const dx = -this.y - this.z;
        const dy = this.x + this.a*this.y;
        const dz = this.b + this.z*(this.x - this.c);
        this.x += dx*dt; 
        this.y += dy*dt; 
        this.z += dz*dt;
        const jitterX = Math.tanh(this.x)*this.jitterFactor;
        const jitterY = Math.tanh(this.y)*this.jitterFactor;
        const jitterZ = Math.tanh(this.z)*this.jitterFactor;
        const phase = (index/totalPoints)*Math.PI*2;
        return new THREE.Vector3(
          jitterX + Math.cos(phase)*(this.jitterFactor*0.1),
          jitterY + Math.sin(phase)*(this.jitterFactor*0.1),
          jitterZ
        );
      }
      // ADDED: Serialization for Rossler internal state
      serializeState() {
        return { x: this.x, y: this.y, z: this.z };
      }
      deserializeState(state) {
        if(state){
          this.x = state.x;
          this.y = state.y;
          this.z = state.z;
        }
      }
    }

    // ------------------ New 3D Parametric Equations ------------------
    class EpicycloidEquation extends EquationBase {
      constructor(){
        super();
        this.R = 80;       // Fixed circle radius
        this.r = 30;       // Rolling circle radius
        this.zAmplitude = 20;
        this.zFrequency = 1.0;
        this.t = 0;
      }
      getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const tVal = this.t + (index/totalPoints)*Math.PI*2;
        const x = (this.R + this.r)*Math.cos(tVal) - this.r*Math.cos(((this.R + this.r)/this.r)*tVal);
        const y = (this.R + this.r)*Math.sin(tVal) - this.r*Math.sin(((this.R + this.r)/this.r)*tVal);
        const z = this.zAmplitude * Math.sin(this.zFrequency * tVal);
        return new THREE.Vector3(x, y, z);
      }
    }

    class HypocycloidEquation extends EquationBase {
      constructor(){
        super();
        this.R = 80;
        this.r = 30;
        this.zAmplitude = 20;
        this.zFrequency = 1.0;
        this.t = 0;
      }
      getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const tVal = this.t + (index/totalPoints)*Math.PI*2;
        const x = (this.R - this.r)*Math.cos(tVal) + this.r*Math.cos(((this.R - this.r)/this.r)*tVal);
        const y = (this.R - this.r)*Math.sin(tVal) - this.r*Math.sin(((this.R - this.r)/this.r)*tVal);
        const z = this.zAmplitude * Math.sin(this.zFrequency * tVal);
        return new THREE.Vector3(x, y, z);
      }
    }

    class CardioidEquation extends EquationBase {
      constructor(){
        super();
        this.a = 80;       // Scale factor for the cardioid
        this.zAmplitude = 20;
        this.zFrequency = 1.0;
        this.t = 0;
      }
      getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const theta = this.t + (index/totalPoints)*Math.PI*2;
        const r = this.a * (1 + Math.cos(theta));
        const x = r * Math.cos(theta);
        const y = r * Math.sin(theta);
        const z = this.zAmplitude * Math.sin(this.zFrequency * theta);
        return new THREE.Vector3(x, y, z);
      }
    }

    class LemniscateEquation extends EquationBase {
      constructor(){
        super();
        this.a = 80;       // Scale factor for the lemniscate
        this.zAmplitude = 20;
        this.zFrequency = 1.0;
        this.t = 0;
      }
      getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const theta = this.t + (index/totalPoints)*Math.PI*2;
        const denominator = 1 + Math.pow(Math.sin(theta), 2);
        const x = this.a * Math.cos(theta) / denominator;
        const y = this.a * Math.sin(theta) * Math.cos(theta) / denominator;
        const z = this.zAmplitude * Math.cos(this.zFrequency * theta);
        return new THREE.Vector3(x, y, z);
      }
    }

    class ButterflyEquation extends EquationBase {
      constructor(){
        super();
        this.scale = 40;   // Overall scale for the butterfly shape
        this.zAmplitude = 20;
        this.zFrequency = 1.0;
        this.t = 0;
      }
      getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const tVal = this.t + (index/totalPoints)*Math.PI*2;
        const common = Math.exp(Math.cos(tVal)) - 2*Math.cos(4*tVal) - Math.pow(Math.sin(tVal/12), 5);
        const x = this.scale * Math.sin(tVal) * common;
        const y = this.scale * Math.cos(tVal) * common;
        const z = this.zAmplitude * Math.sin(this.zFrequency * tVal);
        return new THREE.Vector3(x, y, z);
      }
    }

    /**************** IntegrationModule****************/
    class IntegrationModule {
      constructor(scene, eqModules){
        this.scene = scene;
        this.eqModules = eqModules;
        this.instancedMesh = null;
        this.points = null;
        this.geometry = null;
        this.material = null;
        this.positions = null;
        this.colors = null;
      }

      generateDotTexture() {
        const size = 128;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(
          size / 2, size / 2, 0,
          size / 2, size / 2, size / 2
        );
        const stop0Pos   = parseFloat(document.getElementById('glowStop0Pos').value);
        const stop0Alpha = parseFloat(document.getElementById('glowStop0Alpha').value);
        const stop1Pos   = parseFloat(document.getElementById('glowStop1Pos').value);
        const stop1Alpha = parseFloat(document.getElementById('glowStop1Alpha').value);
        const stop2Pos   = parseFloat(document.getElementById('glowStop2Pos').value);
        const stop2Alpha = parseFloat(document.getElementById('glowStop2Alpha').value);
        const stop3Pos   = parseFloat(document.getElementById('glowStop3Pos').value);
        const stop3Alpha = parseFloat(document.getElementById('glowStop3Alpha').value);
        gradient.addColorStop(stop0Pos, `rgba(255,255,255,${stop0Alpha})`);
        gradient.addColorStop(stop1Pos, `rgba(255,255,255,${stop1Alpha})`);
        gradient.addColorStop(stop2Pos, `rgba(255,255,255,${stop2Alpha})`);
        gradient.addColorStop(stop3Pos, `rgba(255,255,255,${stop3Alpha})`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        return new THREE.CanvasTexture(canvas);
      }

      update(deltaTime, globalTime){
        const globalPointCount = this.eqModules.find(mod => mod.id !== "reactionDiffusion").instance.pointCount;
        const mergedPositions = new Float32Array(globalPointCount * 3);
        const mergedColors = new Float32Array(globalPointCount * 3);
        const globalSpeed = parseFloat(document.getElementById("globalSpeed").value);
        GLOBAL_SPEED = globalSpeed;
        const time = globalTime * globalSpeed;
        for(let i = 0; i < globalPointCount; i++){
          let finalPos = new THREE.Vector3(0, 0, 0);
          this.eqModules.forEach(mod => {
            if(mod.instance.enabled){
              let contrib;
              if(mod.id === "reactionDiffusion"){
                const gridTotal = mod.instance.gridSize * mod.instance.gridSize;
                const gridIndex = Math.floor((i/globalPointCount) * gridTotal);
                contrib = mod.instance.getContribution(gridIndex, gridTotal, time);
              } else if(mod.id === "rossler"){
                contrib = mod.instance.getContribution(i, globalPointCount, time, deltaTime);
              } else {
                contrib = mod.instance.getContribution(i, globalPointCount, time);
              }
              finalPos.add(contrib);
            }
          });
          mergedPositions[i*3]     = finalPos.x;
          mergedPositions[i*3 + 1] = finalPos.y;
          mergedPositions[i*3 + 2] = finalPos.z;
        }
        const paletteSize = 2000;
        const palette = [];
        const baseHue = parseFloat(document.getElementById("globalColor").value);
        for(let j = 0; j < paletteSize; j++){
          const tNorm = j/(paletteSize-1);
          const lightness = 0.3 + tNorm*0.4;
          const hueVariation = 10*Math.sin(tNorm*Math.PI*2);
          const hue = (baseHue + hueVariation + 360) % 360;
          palette.push(hslToRgb(hue,0.8,lightness));
        }
        for(let i = 0; i < globalPointCount; i++){
          const paletteIndex = Math.floor((i/(globalPointCount-1))*(paletteSize-1));
          mergedColors[i*3]   = palette[paletteIndex].r;
          mergedColors[i*3+1] = palette[paletteIndex].g;
          mergedColors[i*3+2] = palette[paletteIndex].b;
        }
        const diskSize = parseFloat(document.getElementById('globalSphereSize').value);
        let modulatedSize = diskSize;
        if(document.getElementById("soundEffectScale").checked && typeof window.soundModBass !== "undefined"){
          const expansionFactor = parseFloat(document.getElementById("soundExpansionFactor").value);
          modulatedSize = diskSize*(1 + window.soundModBass*expansionFactor);
        }
        const useGlow = document.getElementById('useGlowPoints').checked;
        if(useGlow) {
          if(this.instancedMesh) {
            this.scene.remove(this.instancedMesh);
            this.instancedMesh.geometry.dispose();
            this.instancedMesh.material.dispose();
            this.instancedMesh = null;
          }
          if(!this.points || !this.positions || (this.positions.length/3 !== globalPointCount)) {
            if(this.points) {
              this.scene.remove(this.points);
              this.geometry.dispose();
              this.material.dispose();
            }
            this.positions = new Float32Array(globalPointCount * 3);
            this.colors = new Float32Array(globalPointCount * 3);
            this.geometry = new THREE.BufferGeometry();
            this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
            this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
            this.material = new THREE.PointsMaterial({
              size: 4.0,
              vertexColors: true,
              map: this.generateDotTexture(),
              transparent: true,
              blending: THREE.AdditiveBlending,
              depthTest: true,
              depthWrite: false
            });
            this.points = new THREE.Points(this.geometry, this.material);
            this.scene.add(this.points);
          }
          for(let i=0; i < globalPointCount; i++){
            this.positions[i*3]   = mergedPositions[i*3];
            this.positions[i*3+1] = mergedPositions[i*3+1];
            this.positions[i*3+2] = mergedPositions[i*3+2];
            this.colors[i*3]      = mergedColors[i*3];
            this.colors[i*3+1]    = mergedColors[i*3+1];
            this.colors[i*3+2]    = mergedColors[i*3+2];
          }
          this.geometry.attributes.position.needsUpdate = true;
          this.geometry.attributes.color.needsUpdate = true;
          this.material.size = 4.0 * modulatedSize;
          if(document.getElementById("soundEffectEmissive").checked){
            let sensitivity = parseFloat(document.getElementById("soundSensitivity").value);
            this.material.opacity = 0.15 + (window.soundMod || 0)*sensitivity;
            if(this.material.opacity > 1.0) this.material.opacity = 1.0; 
          } else {
            this.material.opacity = 1.0;
          }
        } else {
          if(this.points) {
            this.scene.remove(this.points);
            this.geometry.dispose();
            this.material.dispose();
            this.points = null;
            this.geometry = null;
            this.material = null;
            this.positions = null;
            this.colors = null;
          }
          if(!this.instancedMesh || this.instancedMesh.count !== globalPointCount){
            if(this.instancedMesh){
              this.scene.remove(this.instancedMesh);
              this.instancedMesh.geometry.dispose();
              this.instancedMesh.material.dispose();
            }
            const orbGeom = new THREE.SphereGeometry(1, 16, 16);
            const vertexCount = orbGeom.attributes.position.count;
            const dummyColors = new Float32Array(vertexCount*3);
            for(let i = 0; i < vertexCount; i++){
              dummyColors[i*3] = 1.0;
              dummyColors[i*3+1] = 1.0;
              dummyColors[i*3+2] = 1.0;
            }
            orbGeom.setAttribute('color', new THREE.BufferAttribute(dummyColors, 3));
            const material = new THREE.MeshPhongMaterial({
              vertexColors: true,
              shininess: 30,
              side: THREE.FrontSide,
              emissive: 0xffffff,
              emissiveIntensity: 0.15
            });
            this.instancedMesh = new THREE.InstancedMesh(orbGeom, material, globalPointCount);
            this.instancedMesh.frustumCulled = true;
            this.instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(globalPointCount*3), 3);
            this.scene.add(this.instancedMesh);
          }
          const dummyObj = new THREE.Object3D();
          for(let i = 0; i < globalPointCount; i++){
            dummyObj.position.set(
              mergedPositions[i*3],
              mergedPositions[i*3+1],
              mergedPositions[i*3+2]
            );
            dummyObj.scale.set(modulatedSize, modulatedSize, modulatedSize);
            dummyObj.updateMatrix();
            this.instancedMesh.setMatrixAt(i, dummyObj.matrix);
            this.instancedMesh.instanceColor.setXYZ(
              i,
              mergedColors[i*3],
              mergedColors[i*3+1],
              mergedColors[i*3+2]
            );
          }
          this.instancedMesh.instanceMatrix.needsUpdate = true;
          this.instancedMesh.instanceColor.needsUpdate = true;
          if(document.getElementById("soundEffectEmissive").checked){
            let sensitivity = parseFloat(document.getElementById("soundSensitivity").value);
            this.instancedMesh.material.emissiveIntensity = window.soundMod === null ? 0.15 : window.soundMod*sensitivity;
          } else {
            this.instancedMesh.material.emissiveIntensity = 0.15;
          }
        }
      }
    }

    /**************** SoundModule ****************/
    class SoundModule {
      constructor(){
        this.enabled = false;
        this.sensitivity = 0.25;
        this.frequencyData = null;
        this.analyser = null;
        this.audioContext = null;
      }
      async init(){
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = this.audioContext.createMediaStreamSource(stream);
          this.analyser = this.audioContext.createAnalyser();
          this.analyser.fftSize = 2048;
          const bufferLength = this.analyser.frequencyBinCount;
          this.frequencyData = new Float32Array(bufferLength);
          source.connect(this.analyser);
          this.enabled = true;
          document.getElementById('soundStatus').textContent = "Audio running...";
        } catch(err){
          console.error('Audio initialization error:', err);
          document.getElementById('soundStatus').textContent = "Audio access denied.";
        }
      }
      update(deltaTime){
        if(!this.enabled || !this.analyser) return;
        this.analyser.getFloatFrequencyData(this.frequencyData);
        let maxDb = -Infinity;
        for(let i = 0; i < this.frequencyData.length; i++){
          if(this.frequencyData[i] > maxDb) maxDb = this.frequencyData[i];
        }
        const THRESHOLD_DB = -60;
        window.soundMod = maxDb < THRESHOLD_DB ? 0 : (maxDb - THRESHOLD_DB)/(0 - THRESHOLD_DB);
        let bassMax = -Infinity;
        for(let i = 0; i < 40; i++){
          if(this.frequencyData[i] > bassMax) bassMax = this.frequencyData[i];
        }
        window.soundModBass = bassMax < THRESHOLD_DB ? 0 : (bassMax - THRESHOLD_DB)/(0 - THRESHOLD_DB);
        let midMax = -Infinity;
        for(let i = 41; i < 200 && i < this.frequencyData.length; i++){
          if(this.frequencyData[i] > midMax) midMax = this.frequencyData[i];
        }
        window.soundModMid = midMax < THRESHOLD_DB ? 0 : (midMax - THRESHOLD_DB)/(0 - THRESHOLD_DB);
        let highMax = -Infinity;
        for(let i = 300; i < this.frequencyData.length; i++){
          if(this.frequencyData[i] > highMax) highMax = this.frequencyData[i];
        }
        window.soundModHigh = highMax < THRESHOLD_DB ? 0 : (highMax - THRESHOLD_DB)/(0 - THRESHOLD_DB);
      }
      getOutput(){
        return { frequencyData: this.frequencyData };
      }
      setParameters(params){
        if(params.sensitivity!==undefined) this.sensitivity = params.sensitivity;
      }
    }

    /**************** Persistent Settings & Favorites ****************/
    function saveSettings(){
      const settings = {};
      document.querySelectorAll('#controlPanel input').forEach(input=>{
        if(input.id === "fullscreenToggle") return;
        if(input.id === "screenStaysActive") return;
        if(input.type==="checkbox") {
          settings[input.id] = input.checked;
        } else {
          settings[input.id] = input.value;
        }
      });
      document.querySelectorAll('#controlPanel select').forEach(select=>{
        settings[select.id] = select.value;
      });
      if(window.visualization){
        settings.camera = {
          position: {
            x: window.visualization.camera.position.x,
            y: window.visualization.camera.position.y,
            z: window.visualization.camera.position.z
          },
          zoom: window.visualization.camera.zoom,
          controlsTarget: {
            x: window.visualization.controls.target.x,
            y: window.visualization.controls.target.y,
            z: window.visualization.controls.target.z
          }
        };
      }
      localStorage.setItem('visualizationSettings', JSON.stringify(settings));
    }
    // Expose saveSettings globally for non-module scripts
    window.saveSettings = saveSettings;

    // ADDED: Modified saveFavorite() to also save each equationâ€™s internal state.
    function saveFavorite(){
      const fav = {};
      document.querySelectorAll('#controlPanel input').forEach(input=>{
        if(input.id === "fullscreenToggle") return;
        // Skip saving slideshow controls so user choices remain intact
        if(input.id === "slideshowRandom" || input.id === "slideshowInterval") return;
        fav[input.id] = (input.type==="checkbox") ? input.checked : input.value;
      });
      document.querySelectorAll('#controlPanel select').forEach(select=>{
        fav[select.id] = select.value;
      });
      if(window.visualization){
        fav.camera = {
          position: {
            x: window.visualization.camera.position.x,
            y: window.visualization.camera.position.y,
            z: window.visualization.camera.position.z
          },
          zoom: window.visualization.camera.zoom,
          controlsTarget: {
            x: window.visualization.controls.target.x,
            y: window.visualization.controls.target.y,
            z: window.visualization.controls.target.z
          }
        };
      }
      // ADDED: Save internal state for each equation.
      if(window.visualization && window.visualization.eqModules) {
        fav.equations = {};
        window.visualization.eqModules.forEach(mod => {
          fav.equations[mod.id] = mod.instance.serializeState();
        });
      }
      let favorites = JSON.parse(localStorage.getItem('favoriteSettings') || '[]');
      favorites.push(fav);
      localStorage.setItem('favoriteSettings', JSON.stringify(favorites));
      updateFavoriteList();
    }

    function updateFavoriteList(){
      let favorites = JSON.parse(localStorage.getItem('favoriteSettings') || '[]');
      const favList = document.getElementById('favoriteList');
      favList.innerHTML = '';
      favorites.forEach((fav,index)=>{
        const li = document.createElement('li');
        li.textContent = 'Favorite ' + (index+1);
        const loadBtn = document.createElement('button');
        loadBtn.textContent = 'Load';
        loadBtn.addEventListener('click', ()=>{
          document.body.style.opacity = "0";
          setTimeout(()=>{
            for(const id in fav){
              if(id==="camera") continue;
              if(id==="fullscreenToggle") continue;
              const element = document.getElementById(id);
              if(element){
                if(element.type==="checkbox"){
                  element.checked = fav[id];
                  element.dispatchEvent(new Event('change'));
                } else {
                  element.value = fav[id];
                  element.dispatchEvent(new Event('input'));
                }
              }
            }
            if(fav.camera && window.visualization){
              const cam = fav.camera;
              window.visualization.camera.position.set(cam.position.x, cam.position.y, cam.position.z);
              window.visualization.camera.zoom = cam.zoom;
              window.visualization.camera.updateProjectionMatrix();
              window.visualization.controls.target.set(cam.controlsTarget.x, cam.controlsTarget.y, cam.controlsTarget.z);
              window.visualization.controls.update();
            }
            // ADDED: Restore internal state for each equation.
            if(window.visualization && window.visualization.eqModules && fav.equations){
              window.visualization.eqModules.forEach(mod => {
                if(fav.equations[mod.id] !== undefined){
                  mod.instance.deserializeState(fav.equations[mod.id]);
                }
              });
            }
            saveSettings();
            document.body.style.opacity = "1";
          },500);
        });
        const delBtn = document.createElement('button');
        delBtn.textContent = 'Delete';
        delBtn.addEventListener('click', ()=>{
          deleteFavorite(index);
        });
        li.appendChild(loadBtn);
        li.appendChild(delBtn);
        favList.appendChild(li);
      });
    }
    // Expose updateFavoriteList to the global scope so non-module scripts can access it.
    window.updateFavoriteList = updateFavoriteList;

    function deleteFavorite(index){
      let favorites = JSON.parse(localStorage.getItem('favoriteSettings') || '[]');
      favorites.splice(index, 1);
      localStorage.setItem('favoriteSettings', JSON.stringify(favorites));
      updateFavoriteList();
    }

    // ADDED: Modified loadFavoriteForSlideshow() to also restore internal state.
    function loadFavoriteForSlideshow(fav) {
      document.body.style.transition = "opacity 0.5s ease";
      document.body.style.opacity = "0";
      setTimeout(() => {
        for (const id in fav) {
          // Skip camera, fullscreenToggle, and slideshow controls so they arenâ€™t overwritten
          if (id === "camera" || id === "fullscreenToggle" || id === "slideshowRandom" || id === "slideshowInterval") continue;
          const element = document.getElementById(id);
          if (element) {
            if (element.type === "checkbox") {
              element.checked = fav[id];
              element.dispatchEvent(new Event('change'));
            } else {
              element.value = fav[id];
              element.dispatchEvent(new Event('input'));
            }
          }
        }
        if (fav.camera && window.visualization) {
          const cam = fav.camera;
          window.visualization.camera.position.set(cam.position.x, cam.position.y, cam.position.z);
          window.visualization.camera.zoom = cam.zoom;
          window.visualization.camera.updateProjectionMatrix();
          window.visualization.controls.target.set(cam.controlsTarget.x, cam.controlsTarget.y, cam.controlsTarget.z);
          window.visualization.controls.update();
        }
        // ADDED: Restore internal state for each equation.
        if(window.visualization && window.visualization.eqModules && fav.equations){
          window.visualization.eqModules.forEach(mod => {
            if(fav.equations[mod.id] !== undefined){
              mod.instance.deserializeState(fav.equations[mod.id]);
            }
          });
        }
        saveSettings();
        document.body.style.opacity = "1";
      }, 500);
    }

    /**************** ControlPanel ****************/
    class ControlPanel {
      constructor(eqModules, soundModule){
        this.eqModules = eqModules;
        this.soundModule = soundModule;
        this.initPanel();
      }


      initPanel(){


const categoryMap = {
  // Paths (clear parametric paths)
  "lissajous": "paths",
  "roseCurve": "paths",
  "spiral": "paths",
  "fourierSeries": "paths",
  "torus": "paths",
  "epicycloid": "paths",
  "hypocycloid": "paths",
  "cardioid": "paths",
  "lemniscate": "paths",
  "butterfly": "paths",
  
  // Distortions (dynamic, chaotic, warped)
  "sineDistortion": "distortions",
  "reactionDiffusion": "distortions",
  "phaseRipple": "distortions",
  "zSineWarp": "distortions",
  "radialTwist": "distortions",
  "lorenz": "distortions",
  "shm": "distortions",
  "rossler": "distortions",
  
  // Noises (noiseâ€based equations)
  "noiseEq": "noises",
  "fractalNoise": "noises",
  "ridgedNoise": "noises"
};
        


        document.getElementById('globalPointCount').addEventListener('input', (e)=>{
          const count = parseInt(e.target.value);
          this.eqModules.forEach(mod=>{
            if(mod.id !== "reactionDiffusion"){
              mod.instance.setPointCount(count);
            }
          });
          saveSettings();
        });
        document.querySelector('.moduleHeader[data-target="globalSettings"]').addEventListener('click', function(){
          const content = document.getElementById('globalSettings');
          content.style.display = (content.style.display==='block') ? 'none' : 'block';
        });
        document.getElementById('fullscreenToggle').addEventListener('change', (e) => {
          if(e.target.checked) {
            if(document.documentElement.requestFullscreen) {
              document.documentElement.requestFullscreen();
            } else if(document.documentElement.webkitRequestFullscreen) {
              document.documentElement.webkitRequestFullscreen();
            } else if(document.documentElement.msRequestFullscreen) {
              document.documentElement.msRequestFullscreen();
            }
          } else {
            if(document.exitFullscreen) {
              document.exitFullscreen();
            } else if(document.webkitExitFullscreen) {
              document.webkitExitFullscreen();
            } else if(document.msExitFullscreen) {
              document.msExitFullscreen();
            }
          }
        });
        const eqContainer = document.getElementById('eqModules');
        // Mapping for module header background colors based on desired dark gray level:
        const colorMap = {
          "rossler": "#2b2b2b",
          "roseCurve": "#3c3c3c",
          "spiral": "#3c3c3c",
          "torus": "#3c3c3c",
          "fourierSeries": "#3c3c3c",
          "lissajous": "#3c3c3c",

"epicycloid": "#3c3c3c",
"hypocycloid": "#3c3c3c",
"cardioid": "#3c3c3c",
"lemniscate": "#3c3c3c",
"butterfly": "#3c3c3c",


          "sineDistortion": "#4d4d4d",
          "reactionDiffusion": "#4d4d4d",
          "phaseRipple": "#4d4d4d",
          "zSineWarp": "#4d4d4d",
          "radialTwist": "#4d4d4d",
          "lorenz": "#4d4d4d",
          "shm": "#4d4d4d",
          "noiseEq": "#5e5e5e",
          "fractalNoise": "#5e5e5e",
          "ridgedNoise": "#5e5e5e"
        };
        this.eqModules.forEach(mod=>{
          const header = document.createElement('div');
          header.className = 'moduleHeader';
          // Set header background based on mapping
          if(colorMap[mod.id]){
            header.style.background = colorMap[mod.id];
          }
          const titleSpan = document.createElement('span');
          titleSpan.textContent = mod.name;
          header.appendChild(titleSpan);
          const enableCheckbox = document.createElement('input');
          enableCheckbox.type = "checkbox";
          enableCheckbox.id = mod.id+"_enable";
          enableCheckbox.checked = mod.instance.enabled;
          header.appendChild(enableCheckbox);
          enableCheckbox.addEventListener('change', (e)=>{
            mod.instance.enabled = e.target.checked;
            saveSettings();
          });
          const content = document.createElement('div');
          content.className = 'moduleContent';
          content.id = mod.id;
          let innerHTML = "";
          innerHTML += `
            <div class="controlElement">
              <label>Speed: <input type="range" id="${mod.id}_speed" min="0" max="1.5" step="0.001" value="${mod.instance.speed}"></label>
            </div>
          `;
          switch(mod.id){
            case "lissajous":
              innerHTML += `
                <div class="controlElement">
                  <label>A: <input type="range" id="${mod.id}_A" min="10" max="100" step=".001" value="${mod.instance.A}"></label>
                </div>
                <div class="controlElement">
                  <label>B: <input type="range" id="${mod.id}_B" min="10" max="100" step=".001" value="${mod.instance.B}"></label>
                </div>
                <div class="controlElement">
                  <label>a: <input type="range" id="${mod.id}_a" min="1" max="10" step=".001" value="${mod.instance.a}"></label>
                </div>
                <div class="controlElement">
                  <label>b: <input type="range" id="${mod.id}_b" min="1" max="10" step=".001" value="${mod.instance.b}"></label>
                </div>
                <div class="controlElement">
                  <label>Î´: <input type="range" id="${mod.id}_delta" min="0" max="6.28" step="0.001" value="${mod.instance.delta.toFixed(2)}"></label>
                </div>
              `;
              break;
            case "roseCurve":
              innerHTML += `
                <div class="controlElement">
                  <label>A: <input type="range" id="${mod.id}_A" min="10" max="200" step=".001" value="${mod.instance.A}"></label>
                </div>
                <div class="controlElement">
                  <label>k: <input type="range" id="${mod.id}_k" min="1" max="10" step=".001" value="${mod.instance.k}"></label>
                </div>
              `;
              break;
            case "spiral":
              innerHTML += `
                <div class="controlElement">
                  <label>a: <input type="range" id="${mod.id}_a" min="0" max="20" step="0.001" value="${mod.instance.a}"></label>
                </div>
                <div class="controlElement">
                  <label>b: <input type="range" id="${mod.id}_b" min="0" max="20" step="0.001" value="${mod.instance.b}"></label>
                </div>
              `;
              break;
            case "fourierSeries":
              innerHTML += `
                <div class="controlElement">
                  <label>Amplitude Factor: <input type="range" id="${mod.id}_amp" min="5" max="50" step=".001" value="${mod.instance.baseAmp}"></label>
                </div>
                <div class="controlElement">
                  <label>Number of Terms: <input type="range" id="${mod.id}_terms" min="1" max="20" step=".001" value="${mod.instance.numTerms}"></label>
                </div>
              `;
              break;
            case "shm":
              innerHTML += `
                <div class="controlElement">
                  <label>A: <input type="range" id="${mod.id}_A" min="10" max="100" step=".001" value="${mod.instance.A}"></label>
                </div>
                <div class="controlElement">
                  <label>Ï‰: <input type="range" id="${mod.id}_omega" min="0.5" max="5" step="0.001" value="${mod.instance.omega}"></label>
                </div>
                <div class="controlElement">
                  <label>Ï•: <input type="range" id="${mod.id}_phi" min="0" max="6.28" step="0.001" value="${mod.instance.phi}"></label>
                </div>
              `;
              break;
            case "lorenz":
              innerHTML += `
                <div class="controlElement">
                  <label>Ïƒ: <input type="range" id="${mod.id}_sigma" min="0" max="1.5" step="0.001" value="${mod.instance.sigma}"></label>
                </div>
                <div class="controlElement">
                  <label>Ï: <input type="range" id="${mod.id}_rho" min="0" max="40" step="0.001" value="${mod.instance.rho}"></label>
                </div>
                <div class="controlElement">
                  <label>Î²: <input type="range" id="${mod.id}_beta" min="0" max="5" step="0.001" value="${mod.instance.beta}"></label>
                </div>
              `;
              break;
            case "reactionDiffusion":
              innerHTML += `
                <div class="controlElement">
                  <label>F: <input type="range" id="${mod.id}_F" min="0.01" max="0.1" step="0.001" value="${mod.instance.F}"></label>
                </div>
                <div class="controlElement">
                  <label>k: <input type="range" id="${mod.id}_k" min="0.01" max="0.1" step="0.001" value="${mod.instance.k}"></label>
                </div>
              `;
              break;
            case "noiseEq":
              innerHTML += `
                <div class="controlElement">
                  <label>Scale Factor: <input type="range" id="${mod.id}_scale" min="0" max="25" step=".001" value="${mod.instance.scaleFactor}"></label>
                </div>
              `;
              break;
            case "fractalNoise":
              innerHTML += `
                <div class="controlElement">
                  <label>Scale Factor: <input type="range" id="${mod.id}_scaleFactor" min="0" max="200" step="1" value="${mod.instance.scaleFactor}"></label>
                </div>
                <div class="controlElement">
                  <label>Octaves: <input type="range" id="${mod.id}_octaves" min="1" max="8" step="1" value="${mod.instance.octaves}"></label>
                </div>
                <div class="controlElement">
                  <label>Persistence: <input type="range" id="${mod.id}_persistence" min="0.1" max="1.0" step="0.01" value="${mod.instance.persistence}"></label>
                </div>
              `;
              break;
            case "ridgedNoise":
              innerHTML += `
                <div class="controlElement">
                  <label>Scale Factor: <input type="range" id="${mod.id}_scaleFactor" min="0" max="200" step="1" value="${mod.instance.scaleFactor}"></label>
                </div>
              `;
              break;
            case "torus":
              innerHTML += `
                <div class="controlElement">
                  <label>Major Radius (R): <input type="range" id="${mod.id}_R" min="10" max="100" step="0.001" value="${mod.instance.R}"></label>
                </div>
                <div class="controlElement">
                  <label>Minor Radius (r): <input type="range" id="${mod.id}_r" min="5" max="50" step="0.001" value="${mod.instance.r}"></label>
                </div>
              `;
              break;
            case "rossler":
              innerHTML += `
                <div class="controlElement">
                  <label>Jitter Factor: <input type="range" id="${mod.id}_jitterFactor" min="0.05" max="3" step="0.001" value="${mod.instance.jitterFactor}"></label>
                </div>
                <div class="controlElement">
                  <label>a: <input type="range" id="${mod.id}_a" min="0.1" max="0.3" step="0.001" value="${mod.instance.a}"></label>
                </div>
                <div class="controlElement">
                  <label>b: <input type="range" id="${mod.id}_b" min="0.1" max="0.9" step="0.001" value="${mod.instance.b}"></label>
                </div>
                <div class="controlElement">
                  <label>c: <input type="range" id="${mod.id}_c" min="6" max="9" step="0.001" value="${mod.instance.c}"></label>
                </div>
              `;
              break;
            case "sineDistortion":
              innerHTML += `
                <div class="controlElement">
                  <label>Offset X:
                    <input type="range" id="${mod.id}_offsetX" min="-200" max="200" step="1" value="${mod.instance.offsetX}">
                  </label>
                </div>
                <div class="controlElement">
                  <label>Offset Y:
                    <input type="range" id="${mod.id}_offsetY" min="-200" max="200" step="1" value="${mod.instance.offsetY}">
                  </label>
                </div>
                <div class="controlElement">
                  <label>kDiv:
                    <input type="range" id="${mod.id}_kDiv" min="0" max="50" step="0.001" value="${mod.instance.kDiv}">
                  </label>
                </div>
                <div class="controlElement">
                  <label>kSub:
                    <input type="range" id="${mod.id}_kSub" min="0" max="50" step="0.001" value="${mod.instance.kSub}">
                  </label>
                </div>
                <div class="controlElement">
                  <label>Scale Factor:
                    <input type="range" id="${mod.id}_scaleFactor" min="0" max="5" step="0.001" value="${mod.instance.scaleFactor}">
                  </label>
                </div>
                <div class="controlElement">
                  <label>X Amplitude:
                    <input type="range" id="${mod.id}_xAmplitude" min="0" max="50" step="0.001" value="${mod.instance.xAmplitude}">
                  </label>
                </div>
                <div class="controlElement">
                  <label>Y Amplitude:
                    <input type="range" id="${mod.id}_yAmplitude" min="0" max="50" step="0.001" value="${mod.instance.yAmplitude}">
                  </label>
                </div>
              `;
              break;
            case "phaseRipple":
              innerHTML += `
                <div class="controlElement">
                  <label>Phase Factor:
                    <input type="range" id="${mod.id}_phaseFactor" min="0" max="1" step="0.001" value="${mod.instance.phaseFactor}">
                  </label>
                </div>
                <div class="controlElement">
                  <label>X Amplitude:
                    <input type="range" id="${mod.id}_xAmplitude" min="0" max="50" step="0.001" value="${mod.instance.xAmplitude}">
                  </label>
                </div>
                <div class="controlElement">
                  <label>Y Amplitude:
                    <input type="range" id="${mod.id}_yAmplitude" min="0" max="50" step="0.001" value="${mod.instance.yAmplitude}">
                  </label>
                </div>
              `;
              break;
            case "zSineWarp":
              innerHTML += `
                <div class="controlElement">
                  <label>Z Amplitude:
                    <input type="range" id="${mod.id}_zAmplitude" min="0" max="100" step="0.001" value="${mod.instance.zAmplitude}">
                  </label>
                </div>
                <div class="controlElement">
                  <label>Frequency:
                    <input type="range" id="${mod.id}_frequency" min="0" max="5" step="0.001" value="${mod.instance.frequency}">
                  </label>
                </div>
              `;
              break;
            case "radialTwist":
              innerHTML += `
                <div class="controlElement">
                  <label>Radial Factor:
                    <input type="range" id="${mod.id}_radialFactor" min="0" max="5" step="0.001" value="${mod.instance.radialFactor}">
                  </label>
                </div>
                <div class="controlElement">
                  <label>Twist Factor:
                    <input type="range" id="${mod.id}_twistFactor" min="0" max="10" step="0.001" value="${mod.instance.twistFactor}">
                  </label>
                </div>
                <div class="controlElement">
                  <label>Z Wave Freq:
                    <input type="range" id="${mod.id}_zWaveFrequency" min="0" max="5" step="0.001" value="${mod.instance.zWaveFrequency}">
                  </label>
                </div>
                <div class="controlElement">
                  <label>Z Wave Amp:
                    <input type="range" id="${mod.id}_zWaveAmplitude" min="0" max="50" step="0.001" value="${mod.instance.zWaveAmplitude}">
                  </label>
                </div>
              `;
              break;

case "epicycloid":
  innerHTML += `
    <div class="controlElement">
      <label>Fixed Radius (R):
        <input type="range" id="${mod.id}_R" min="10" max="150" step="0.1" value="${mod.instance.R}">
      </label>
    </div>
    <div class="controlElement">
      <label>Rolling Radius (r):
        <input type="range" id="${mod.id}_r" min="5" max="100" step="0.1" value="${mod.instance.r}">
      </label>
    </div>
    <div class="controlElement">
      <label>Z Amplitude:
        <input type="range" id="${mod.id}_zAmplitude" min="0" max="50" step="0.1" value="${mod.instance.zAmplitude}">
      </label>
    </div>
    <div class="controlElement">
      <label>Z Frequency:
        <input type="range" id="${mod.id}_zFrequency" min="0.1" max="5" step="0.1" value="${mod.instance.zFrequency}">
      </label>
    </div>
  `;
  break;
case "hypocycloid":
  innerHTML += `
    <div class="controlElement">
      <label>Fixed Radius (R):
        <input type="range" id="${mod.id}_R" min="10" max="150" step="0.1" value="${mod.instance.R}">
      </label>
    </div>
    <div class="controlElement">
      <label>Rolling Radius (r):
        <input type="range" id="${mod.id}_r" min="5" max="100" step="0.1" value="${mod.instance.r}">
      </label>
    </div>
    <div class="controlElement">
      <label>Z Amplitude:
        <input type="range" id="${mod.id}_zAmplitude" min="0" max="50" step="0.1" value="${mod.instance.zAmplitude}">
      </label>
    </div>
    <div class="controlElement">
      <label>Z Frequency:
        <input type="range" id="${mod.id}_zFrequency" min="0.1" max="5" step="0.1" value="${mod.instance.zFrequency}">
      </label>
    </div>
  `;
  break;
case "cardioid":
  innerHTML += `
    <div class="controlElement">
      <label>Scale Factor (a):
        <input type="range" id="${mod.id}_a" min="10" max="150" step="0.1" value="${mod.instance.a}">
      </label>
    </div>
    <div class="controlElement">
      <label>Z Amplitude:
        <input type="range" id="${mod.id}_zAmplitude" min="0" max="50" step="0.1" value="${mod.instance.zAmplitude}">
      </label>
    </div>
    <div class="controlElement">
      <label>Z Frequency:
        <input type="range" id="${mod.id}_zFrequency" min="0.1" max="5" step="0.1" value="${mod.instance.zFrequency}">
      </label>
    </div>
  `;
  break;
case "lemniscate":
  innerHTML += `
    <div class="controlElement">
      <label>Scale Factor (a):
        <input type="range" id="${mod.id}_a" min="10" max="150" step="0.1" value="${mod.instance.a}">
      </label>
    </div>
    <div class="controlElement">
      <label>Z Amplitude:
        <input type="range" id="${mod.id}_zAmplitude" min="0" max="50" step="0.1" value="${mod.instance.zAmplitude}">
      </label>
    </div>
    <div class="controlElement">
      <label>Z Frequency:
        <input type="range" id="${mod.id}_zFrequency" min="0.1" max="5" step="0.1" value="${mod.instance.zFrequency}">
      </label>
    </div>
  `;
  break;
case "butterfly":
  innerHTML += `
    <div class="controlElement">
      <label>Scale:
        <input type="range" id="${mod.id}_scale" min="10" max="100" step="0.1" value="${mod.instance.scale}">
      </label>
    </div>
    <div class="controlElement">
      <label>Z Amplitude:
        <input type="range" id="${mod.id}_zAmplitude" min="0" max="50" step="0.1" value="${mod.instance.zAmplitude}">
      </label>
    </div>
    <div class="controlElement">
      <label>Z Frequency:
        <input type="range" id="${mod.id}_zFrequency" min="0.1" max="5" step="0.1" value="${mod.instance.zFrequency}">
      </label>
    </div>
  `;
  break;
          }
          content.innerHTML = innerHTML;
          // eqContainer.appendChild(header);
          // eqContainer.appendChild(content);


const containerId = categoryMap[mod.id] + "Content";
document.getElementById(containerId).appendChild(header);
document.getElementById(containerId).appendChild(content);
          
          const speedInput = content.querySelector(`#${mod.id}_speed`);
          if(speedInput){
            speedInput.addEventListener('input', (e) => { 
              mod.instance.speed = parseFloat(e.target.value);
              saveSettings();
            });
          }
          if(mod.id === "rossler"){
            content.querySelector(`#${mod.id}_jitterFactor`).addEventListener('input', (e) => {
              const newVal = parseFloat(e.target.value);
              mod.instance.jitterFactor = newVal;
              mod.instance.baseJitterFactor = newVal;
              saveSettings();
            });
            content.querySelector(`#${mod.id}_a`).addEventListener('input', (e) => { mod.instance.a = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_b`).addEventListener('input', (e) => { mod.instance.b = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_c`).addEventListener('input', (e) => { mod.instance.c = parseFloat(e.target.value); saveSettings(); });
          } else if(mod.id === "lissajous"){
            content.querySelector(`#${mod.id}_A`).addEventListener('input', (e) => { mod.instance.A = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_B`).addEventListener('input', (e) => { mod.instance.B = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_a`).addEventListener('input', (e) => { mod.instance.a = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_b`).addEventListener('input', (e) => { mod.instance.b = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_delta`).addEventListener('input', (e) => { mod.instance.delta = parseFloat(e.target.value); saveSettings(); });
          } else if(mod.id === "roseCurve"){
            content.querySelector(`#${mod.id}_A`).addEventListener('input', (e) => { mod.instance.A = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_k`).addEventListener('input', (e) => { mod.instance.k = parseFloat(e.target.value); saveSettings(); });
          } else if(mod.id === "spiral"){
            content.querySelector(`#${mod.id}_a`).addEventListener('input', (e) => { mod.instance.a = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_b`).addEventListener('input', (e) => { mod.instance.b = parseFloat(e.target.value); saveSettings(); });
          } else if(mod.id === "fourierSeries"){
            content.querySelector(`#${mod.id}_amp`).addEventListener('input', (e) => {
              mod.instance.baseAmp = parseFloat(e.target.value);
              for(let n = 1; n <= mod.instance.numTerms; n++){
                mod.instance.A[n-1] = mod.instance.baseAmp/n;
              }
              saveSettings();
            });
            content.querySelector(`#${mod.id}_terms`).addEventListener('input', (e) => {
              mod.instance.numTerms = parseInt(e.target.value);
              mod.instance.A = [];
              mod.instance.phases = [];
              for(let n = 1; n <= mod.instance.numTerms; n++){
                mod.instance.A.push(mod.instance.baseAmp/n);
                mod.instance.phases.push(Math.random()*Math.PI*2);
              }
              saveSettings();
            });
          } else if(mod.id === "shm"){
            content.querySelector(`#${mod.id}_A`).addEventListener('input', (e) => { mod.instance.A = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_omega`).addEventListener('input', (e) => { mod.instance.omega = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_phi`).addEventListener('input', (e) => { mod.instance.phi = parseFloat(e.target.value); saveSettings(); });
          } else if(mod.id === "lorenz"){
            content.querySelector(`#${mod.id}_sigma`).addEventListener('input', (e) => { mod.instance.sigma = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_rho`).addEventListener('input', (e) => { mod.instance.rho = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_beta`).addEventListener('input', (e) => { mod.instance.beta = parseFloat(e.target.value); saveSettings(); });
          } else if(mod.id === "reactionDiffusion"){
            content.querySelector(`#${mod.id}_F`).addEventListener('input', (e) => { mod.instance.F = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_k`).addEventListener('input', (e) => { mod.instance.k = parseFloat(e.target.value); saveSettings(); });
          } else if(mod.id === "noiseEq"){
            content.querySelector(`#${mod.id}_scale`).addEventListener('input', (e) => { mod.instance.scaleFactor = parseFloat(e.target.value); saveSettings(); });
          } else if(mod.id === "fractalNoise"){
            content.querySelector(`#${mod.id}_scaleFactor`).addEventListener('input', (e) => {
              mod.instance.scaleFactor = parseFloat(e.target.value);
              saveSettings();
            });
            content.querySelector(`#${mod.id}_octaves`).addEventListener('input', (e) => {
              mod.instance.octaves = parseInt(e.target.value);
              saveSettings();
            });
            content.querySelector(`#${mod.id}_persistence`).addEventListener('input', (e) => {
              mod.instance.persistence = parseFloat(e.target.value);
              saveSettings();
            });
          } else if(mod.id === "ridgedNoise"){
            content.querySelector(`#${mod.id}_scaleFactor`).addEventListener('input', (e) => {
              mod.instance.scaleFactor = parseFloat(e.target.value);
              saveSettings();
            });
          } else if(mod.id === "torus"){
            content.querySelector(`#${mod.id}_R`).addEventListener('input', (e) => { mod.instance.R = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_r`).addEventListener('input', (e) => { mod.instance.r = parseFloat(e.target.value); saveSettings(); });
          } 
          else if(mod.id === "sineDistortion"){
            content.querySelector(`#${mod.id}_offsetX`).addEventListener('input', (e) => { mod.instance.offsetX = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_offsetY`).addEventListener('input', (e) => { mod.instance.offsetY = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_kDiv`).addEventListener('input', (e) => { mod.instance.kDiv = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_kSub`).addEventListener('input', (e) => { mod.instance.kSub = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_scaleFactor`).addEventListener('input', (e) => { mod.instance.scaleFactor = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_xAmplitude`).addEventListener('input', (e) => { mod.instance.xAmplitude = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_yAmplitude`).addEventListener('input', (e) => { mod.instance.yAmplitude = parseFloat(e.target.value); saveSettings(); });
          } else if(mod.id === "phaseRipple"){
            content.querySelector(`#${mod.id}_phaseFactor`).addEventListener('input', (e) => { mod.instance.phaseFactor = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_xAmplitude`).addEventListener('input', (e) => { mod.instance.xAmplitude = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_yAmplitude`).addEventListener('input', (e) => { mod.instance.yAmplitude = parseFloat(e.target.value); saveSettings(); });
          } else if(mod.id === "zSineWarp"){
            content.querySelector(`#${mod.id}_zAmplitude`).addEventListener('input', (e) => { mod.instance.zAmplitude = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_frequency`).addEventListener('input', (e) => { mod.instance.frequency = parseFloat(e.target.value); saveSettings(); });
          } else if(mod.id === "radialTwist"){
            content.querySelector(`#${mod.id}_radialFactor`).addEventListener('input', (e) => { mod.instance.radialFactor = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_twistFactor`).addEventListener('input', (e) => { mod.instance.twistFactor = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_zWaveFrequency`).addEventListener('input', (e) => { mod.instance.zWaveFrequency = parseFloat(e.target.value); saveSettings(); });
            content.querySelector(`#${mod.id}_zWaveAmplitude`).addEventListener('input', (e) => { mod.instance.zWaveAmplitude = parseFloat(e.target.value); saveSettings(); });
          }


else if(mod.id === "epicycloid"){
  content.querySelector(`#${mod.id}_R`).addEventListener('input', (e) => { mod.instance.R = parseFloat(e.target.value); saveSettings(); });
  content.querySelector(`#${mod.id}_r`).addEventListener('input', (e) => { mod.instance.r = parseFloat(e.target.value); saveSettings(); });
  content.querySelector(`#${mod.id}_zAmplitude`).addEventListener('input', (e) => { mod.instance.zAmplitude = parseFloat(e.target.value); saveSettings(); });
  content.querySelector(`#${mod.id}_zFrequency`).addEventListener('input', (e) => { mod.instance.zFrequency = parseFloat(e.target.value); saveSettings(); });
} else if(mod.id === "hypocycloid"){
  content.querySelector(`#${mod.id}_R`).addEventListener('input', (e) => { mod.instance.R = parseFloat(e.target.value); saveSettings(); });
  content.querySelector(`#${mod.id}_r`).addEventListener('input', (e) => { mod.instance.r = parseFloat(e.target.value); saveSettings(); });
  content.querySelector(`#${mod.id}_zAmplitude`).addEventListener('input', (e) => { mod.instance.zAmplitude = parseFloat(e.target.value); saveSettings(); });
  content.querySelector(`#${mod.id}_zFrequency`).addEventListener('input', (e) => { mod.instance.zFrequency = parseFloat(e.target.value); saveSettings(); });
} else if(mod.id === "cardioid"){
  content.querySelector(`#${mod.id}_a`).addEventListener('input', (e) => { mod.instance.a = parseFloat(e.target.value); saveSettings(); });
  content.querySelector(`#${mod.id}_zAmplitude`).addEventListener('input', (e) => { mod.instance.zAmplitude = parseFloat(e.target.value); saveSettings(); });
  content.querySelector(`#${mod.id}_zFrequency`).addEventListener('input', (e) => { mod.instance.zFrequency = parseFloat(e.target.value); saveSettings(); });
} else if(mod.id === "lemniscate"){
  content.querySelector(`#${mod.id}_a`).addEventListener('input', (e) => { mod.instance.a = parseFloat(e.target.value); saveSettings(); });
  content.querySelector(`#${mod.id}_zAmplitude`).addEventListener('input', (e) => { mod.instance.zAmplitude = parseFloat(e.target.value); saveSettings(); });
  content.querySelector(`#${mod.id}_zFrequency`).addEventListener('input', (e) => { mod.instance.zFrequency = parseFloat(e.target.value); saveSettings(); });
} else if(mod.id === "butterfly"){
  content.querySelector(`#${mod.id}_scale`).addEventListener('input', (e) => { mod.instance.scale = parseFloat(e.target.value); saveSettings(); });
  content.querySelector(`#${mod.id}_zAmplitude`).addEventListener('input', (e) => { mod.instance.zAmplitude = parseFloat(e.target.value); saveSettings(); });
  content.querySelector(`#${mod.id}_zFrequency`).addEventListener('input', (e) => { mod.instance.zFrequency = parseFloat(e.target.value); saveSettings(); });
}

          header.addEventListener('click', function(e){
            if(e.target !== enableCheckbox){
              content.style.display = (content.style.display==='block') ? 'none' : 'block';
            }
          });
        });
        document.getElementById('soundEnable').addEventListener('change', (e) => { 
          this.soundModule.enabled = e.target.checked; 
          saveSettings();
        });
        document.getElementById('soundSensitivity').addEventListener('input', (e) => { 
          this.soundModule.sensitivity = parseFloat(e.target.value);
          saveSettings();
        });
        document.getElementById('soundExpansionFactor').addEventListener('input', saveSettings);
        document.getElementById('startAudio').addEventListener('click', () => {
          this.soundModule.init();
          document.getElementById('startAudio').disabled = true;
        });
        document.querySelectorAll('.moduleHeader[data-target="soundModule"]').forEach(header => {
          header.addEventListener('click', function(){
            const soundContent = document.getElementById('soundModule');
            soundContent.style.display = (soundContent.style.display==='block') ? 'none' : 'block';
          });
        });


document.getElementById('soundJitterEnable').addEventListener('change', function(e) {
  if (e.target.checked) {
    // Automatically enable the Rossler equation.
    if (window.visualization && window.visualization.rossler) {
      window.visualization.rossler.enabled = true;
    }
    // Optionally update the Rossler control panel checkbox, if it exists.
    const rosslerCheckbox = document.getElementById('rossler_enable');
    if (rosslerCheckbox) {
      rosslerCheckbox.checked = true;
    }
  }
});
        


        const glowCheckbox = document.getElementById('useGlowPoints');
        const glowPointsHeader = document.getElementById('glowPointsHeader');
        const glowPointsSettings = document.getElementById('glowPointsSettings');
        glowCheckbox.addEventListener('change', () => {
          if(glowCheckbox.checked) {
            glowPointsHeader.style.display = 'block';
            glowPointsSettings.style.display = 'none';
          } else {
            glowPointsHeader.style.display = 'none';
            glowPointsSettings.style.display = 'none';
          }
          saveSettings();
        });
        glowPointsHeader.addEventListener('click', () => {
          if(!glowCheckbox.checked) return;
          glowPointsSettings.style.display = (
            glowPointsSettings.style.display === 'block'
          ) ? 'none' : 'block';
        });
        glowPointsSettings.addEventListener('mouseleave', () => {
          if(glowCheckbox.checked) {
            glowPointsSettings.style.display = 'none';
          }
        });
        [
          'glowStop0Pos','glowStop0Alpha',
          'glowStop1Pos','glowStop1Alpha',
          'glowStop2Pos','glowStop2Alpha',
          'glowStop3Pos','glowStop3Alpha'
        ].forEach(id => {
          document.getElementById(id).addEventListener('input', () => {
            saveSettings();
            if(glowCheckbox.checked && window.visualization){
              const integrationMod = window.visualization.integrationModule;
              if(integrationMod && integrationMod.points && integrationMod.material){
                integrationMod.material.map.dispose();
                integrationMod.material.map = integrationMod.generateDotTexture();
                integrationMod.material.needsUpdate = true;
              }
            }
          });
        });
        document.getElementById('controlPanel').addEventListener('input', saveSettings);
        document.getElementById('saveFavorite').addEventListener('click', saveFavorite);
        updateFavoriteList();
      }
    }

    /**************** Visualization ****************/
    class Visualization {
      constructor(){
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000000);
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 10000);
        this.camera.position.set(0,0,300);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.1;

        // saves camera settings on changes to view by user
        this.controls.addEventListener('change', () => {
           saveSettings();
        });

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(100,100,100);
        this.scene.add(directionalLight);
        this.lissajous = new LissajousEquation();
        this.roseCurve = new RoseCurveEquation();
        this.spiral = new SpiralEquation();
        this.fourierSeries = new FourierSeriesEquation();
        this.shm = new SHMEquation();
        this.lorenz = new LorenzAttractorEquation();
        this.reactionDiffusion = new ReactionDiffusionEquation();
        this.noiseEq = new NoiseEquation();
        this.fractalNoise = new FractalNoiseEquation();
        this.ridgedNoise = new RidgedNoiseEquation();
        this.torusEq = new TorusEquation();
        this.rossler = new RosslerEquation();
        this.rossler.baseJitterFactor = this.rossler.jitterFactor;
        this.sineDistortion = new SineDistortionEquation();
        this.phaseRipple   = new PhaseRippleEquation();
        this.zSineWarp     = new ZSineWarpEquation();
        this.radialTwist   = new RadialTwistEquation();

this.epicycloid = new EpicycloidEquation();
this.hypocycloid = new HypocycloidEquation();
this.cardioid = new CardioidEquation();
this.lemniscate = new LemniscateEquation();
this.butterfly = new ButterflyEquation();

        // Defaults at first start
        this.lissajous.enabled = false;
        this.spiral.enabled = false;
        this.fourierSeries.enabled = false;
        this.shm.enabled = false;
        this.lorenz.enabled = false;
        this.reactionDiffusion.enabled = false;
        this.noiseEq.enabled = false;
        this.fractalNoise.enabled = false;
        this.torusEq.enabled = false;
        this.rossler.enabled = false;
        this.sineDistortion.enabled = false;
        this.phaseRipple.enabled = false;
        this.zSineWarp.enabled = false;
        this.radialTwist.enabled = false;

this.epicycloid.enabled = false;
this.hypocycloid.enabled = false;
this.cardioid.enabled = false;
this.lemniscate.enabled = false;
this.butterfly.enabled = false;

        // Reordered eqModules array per the requested order and renaming:
        this.eqModules = [
          { id: "rossler",          name: "Rossler Jitter",         instance: this.rossler },
          { id: "roseCurve",        name: "Rose Curve",             instance: this.roseCurve },
          { id: "spiral",           name: "Spiral Curve",           instance: this.spiral },
          { id: "torus",            name: "Torus",                  instance: this.torusEq },
          { id: "fourierSeries",    name: "Fourier Series",         instance: this.fourierSeries },
          { id: "lissajous",        name: "Lissajous",              instance: this.lissajous },

  { id: "epicycloid",       name: "Epicycloid",             instance: this.epicycloid },
  { id: "hypocycloid",      name: "Hypocycloid",            instance: this.hypocycloid },
  { id: "cardioid",         name: "Cardioid",               instance: this.cardioid },
  { id: "lemniscate",       name: "Lemniscate",             instance: this.lemniscate },
  { id: "butterfly",        name: "Butterfly",              instance: this.butterfly },

          { id: "sineDistortion",   name: "Sine Distortion",        instance: this.sineDistortion },
          { id: "reactionDiffusion",name: "Reaction-Diffusion",     instance: this.reactionDiffusion },
          { id: "phaseRipple",      name: "Phase Ripple",           instance: this.phaseRipple },
          { id: "zSineWarp",        name: "Z-Sine Warp",            instance: this.zSineWarp },
          { id: "radialTwist",      name: "Radial Twist",           instance: this.radialTwist },
          { id: "lorenz",           name: "Lorenz Attractor",      instance: this.lorenz },
          { id: "shm",              name: "Simple Harmonic Motion", instance: this.shm },
          { id: "noiseEq",          name: "Simplex Noise",          instance: this.noiseEq },
          { id: "fractalNoise",     name: "Fractal Noise",          instance: this.fractalNoise },
          { id: "ridgedNoise",      name: "Ridged Noise",           instance: this.ridgedNoise }
        ];
        this.integrationModule = new IntegrationModule(this.scene, this.eqModules);
        this.soundModule = new SoundModule();
        window.addEventListener('resize', this.onWindowResize.bind(this), false);
        this.lastTime = performance.now();
        this.globalTime = 0;
        this.animate();
      }

      onWindowResize(){
        this.camera.aspect = window.innerWidth/window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
      }

      animate(){
        requestAnimationFrame(this.animate.bind(this));
        const currentTime = performance.now();
        const deltaTime = (currentTime - this.lastTime)/1000;
        this.lastTime = currentTime;
        this.globalTime += deltaTime;
        this.integrationModule.update(deltaTime, this.globalTime);
        this.soundModule.update(deltaTime);
        const jitterEnableEl = document.getElementById('soundJitterEnable');
        if(
          jitterEnableEl && jitterEnableEl.checked &&
          document.getElementById('soundJitterLow') &&
          document.getElementById('soundJitterHigh') &&
          document.getElementById('soundJitterModStrength')
        ){
          let low = parseInt(document.getElementById('soundJitterLow').value);
          let high = parseInt(document.getElementById('soundJitterHigh').value);
          if(low > high) [low, high] = [high, low];
          let modStrength = parseFloat(document.getElementById('soundJitterModStrength').value);
          let freqData = this.soundModule.frequencyData;
          if(freqData && freqData.length > 0){
            let maxRatio = 0;
            const maxBin = freqData.length - 1;
            for(let i = low; i <= high && i < freqData.length; i++){
              let dB = freqData[i];
              let ratio = (dB + 100)/100;
              ratio = Math.max(0, Math.min(1, ratio));
              let scaleFactor = 1 + (i/maxBin)*100;
              let adjustedRatio = ratio * scaleFactor;
              if(adjustedRatio > maxRatio){
                maxRatio = adjustedRatio;
              }
            }
            let offset = modStrength * maxRatio;
            let newJitter = this.rossler.baseJitterFactor + offset;
            this.rossler.jitterFactor = newJitter;
          }
        } else {
          this.rossler.jitterFactor = this.rossler.baseJitterFactor;
        }
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
      }
    }

    /**************** Main Initialization ****************/
    document.addEventListener('DOMContentLoaded', () => {
      const viz = new Visualization();
      window.visualization = viz;
      new ControlPanel(viz.eqModules, viz.soundModule);
      loadSettings();




    function loadSettings(){
      const settingsStr = localStorage.getItem('visualizationSettings');
      if(settingsStr){
        const settings = JSON.parse(settingsStr);
        for(const id in settings){
          if(id==="camera") continue;
          if(id==="fullscreenToggle") continue;
          const element = document.getElementById(id);
          if(element){
            if(element.type==="checkbox"){
              element.checked = settings[id];
              element.dispatchEvent(new Event('change'));
            } else {
              element.value = settings[id];
              element.dispatchEvent(new Event('input'));
            }
          }
        }
        if(settings.camera && window.visualization){
          const cam = settings.camera;
          window.visualization.camera.position.set(cam.position.x, cam.position.y, cam.position.z);
          window.visualization.camera.zoom = cam.zoom;
          window.visualization.camera.updateProjectionMatrix();
          window.visualization.controls.target.set(cam.controlsTarget.x, cam.controlsTarget.y, cam.controlsTarget.z);
          window.visualization.controls.update();
        }
      }
    }





  const syncJitterAndRossler = () => {
    const jitterCheckbox = document.getElementById('soundJitterEnable');
    if (jitterCheckbox && jitterCheckbox.checked) {
      if (window.visualization && window.visualization.rossler && !window.visualization.rossler.enabled) {
        window.visualization.rossler.enabled = true;
        // Optionally update the Rossler control panel checkbox, if present:
        const rosslerCheckbox = document.getElementById('rossler_enable');
        if (rosslerCheckbox) {
          rosslerCheckbox.checked = true;
        }
      }
    }
  };

  // Run the check immediately on page load
  syncJitterAndRossler();
  // And update whenever the Jitter checkbox changes
  document.getElementById('soundJitterEnable').addEventListener('change', syncJitterAndRossler);

  // --- Begin: Show control panel for 3 seconds ---
  const controlPanel = document.getElementById('controlPanel');
  // Force the control panel to show immediately
  controlPanel.style.transform = "translateX(0)";
  controlPanel.style.opacity = "1";
  // After 3 seconds, hide it again
setTimeout(() => {
  controlPanel.style.removeProperty('transform');
  controlPanel.style.removeProperty('opacity');
}, 3000);

  // --- End: Show control panel for 3 seconds ---


  // Immediately enable the sound module on start
  viz.soundModule.init();
  document.getElementById('startAudio').disabled = true;



    });

    document.body.classList.add('hide-cursor');
    const controlPanel = document.getElementById('controlPanel');
    controlPanel.addEventListener('mouseenter', () => {
      document.body.classList.remove('hide-cursor');
    });
    controlPanel.addEventListener('mouseleave', () => {
      document.body.classList.add('hide-cursor');
    });

    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") {
        if (window.visualization) {
          window.visualization.lastTime = performance.now();
          window.visualization.animate();
        }
        if (window.visualization &&
            window.visualization.soundModule &&
            window.visualization.soundModule.audioContext)
        {
          const ctx = window.visualization.soundModule.audioContext;
          if (ctx.state === "suspended") {
            ctx.resume();
          }
        }
      }
    });
  </script>

  <!-- ===================================================================== -->
  <!-- ============== SINGLE CHECKBOX WAKE LOCK INTEGRATION ================= -->
  <!-- ===================================================================== -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const screenStaysActive = document.getElementById('screenStaysActive');
      let wakeLock = null;
      const requestWakeLock = async () => {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
        } catch (err) {
          console.error(`Wake lock request failed: ${err.name}, ${err.message}`);
        }
      };
      const releaseWakeLock = async () => {
        if (wakeLock !== null) {
          try {
            await wakeLock.release();
            wakeLock = null;
          } catch (err) {
            console.error(`Wake lock release failed: ${err.name}, ${err.message}`);
          }
        }
      };
      const handleVisibilityChange = async () => {
        if (screenStaysActive.checked && document.visibilityState === 'visible') {
          await requestWakeLock();
        }
      };
      screenStaysActive.addEventListener('change', async () => {
        if (screenStaysActive.checked) {
          await requestWakeLock();
          document.addEventListener('visibilitychange', handleVisibilityChange);
        } else {
          await releaseWakeLock();
          document.removeEventListener('visibilitychange', handleVisibilityChange);
        }
      });
    });
  </script>
  <!-- ===================================================================== -->

  <!-- New Script: Slideshow of Favorites -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      let slideshowTimer = null;
      let slideshowActive = false;
      let slideshowIndex = 0;
      let slideshowFavorites = [];

      // This function loads the favorite with a fade out/in (each 0.5s)
      function loadFavoriteForSlideshow(fav) {
        document.body.style.transition = "opacity 0.5s ease";
        document.body.style.opacity = "0";
        setTimeout(() => {
          for (const id in fav) {
            // Skip camera, fullscreenToggle, and slideshow controls so they arenâ€™t overwritten
            if (id === "camera" || id === "fullscreenToggle" || id === "slideshowRandom" || id === "slideshowInterval") continue;
            const element = document.getElementById(id);
            if (element) {
              if (element.type === "checkbox") {
                element.checked = fav[id];
                element.dispatchEvent(new Event('change'));
              } else {
                element.value = fav[id];
                element.dispatchEvent(new Event('input'));
              }
            }
          }
          if (fav.camera && window.visualization) {
            const cam = fav.camera;
            window.visualization.camera.position.set(cam.position.x, cam.position.y, cam.position.z);
            window.visualization.camera.zoom = cam.zoom;
            window.visualization.camera.updateProjectionMatrix();
            window.visualization.controls.target.set(cam.controlsTarget.x, cam.controlsTarget.y, cam.controlsTarget.z);
            window.visualization.controls.update();
          }
          // ADDED: Restore internal state for each equation.
          if(window.visualization && window.visualization.eqModules && fav.equations){
            window.visualization.eqModules.forEach(mod => {
              if(fav.equations[mod.id] !== undefined){
                mod.instance.deserializeState(fav.equations[mod.id]);
              }
            });
          }
          saveSettings();
          document.body.style.opacity = "1";
        }, 500);
      }

      function nextSlideshow() {
        if (!slideshowActive) return;
        slideshowFavorites = JSON.parse(localStorage.getItem('favoriteSettings') || '[]');
        if (slideshowFavorites.length === 0) {
          cancelSlideshow();
          return;
        }
        if (document.getElementById('slideshowRandom').checked) {
          slideshowIndex = Math.floor(Math.random() * slideshowFavorites.length);
        } else {
          slideshowIndex = (slideshowIndex + 1) % slideshowFavorites.length;
        }
        loadFavoriteForSlideshow(slideshowFavorites[slideshowIndex]);
        const intervalMinutes = parseInt(document.getElementById('slideshowInterval').value, 10);
        const intervalMs = intervalMinutes * 60 * 1000;
        slideshowTimer = setTimeout(nextSlideshow, intervalMs);
      }

      // New cancellation logic: only if the mouse is in the rightmost 300 pixels
      function mouseMoveCancelHandler(e) {
        if (e.clientX >= window.innerWidth - 300) {
          cancelSlideshow();
        }
      }

      function startSlideshow() {
        // For fullscreen: if already on, toggle it off then on with a delay; otherwise simply turn it on.
        const fullscreenToggle = document.getElementById("fullscreenToggle");
        if (fullscreenToggle) {
          if (fullscreenToggle.checked === true) {
            fullscreenToggle.checked = false;
            fullscreenToggle.dispatchEvent(new Event("change"));
            setTimeout(() => {
              fullscreenToggle.checked = true;
              fullscreenToggle.dispatchEvent(new Event("change"));
            }, 150);
          } else {
            fullscreenToggle.checked = true;
            fullscreenToggle.dispatchEvent(new Event("change"));
          }
        }

        // For "screen stays active": if already on, toggle it off then on with a delay; otherwise simply turn it on.
        const screenStaysActive = document.getElementById("screenStaysActive");
        if (screenStaysActive) {
          if (screenStaysActive.checked === true) {
            screenStaysActive.checked = false;
            screenStaysActive.dispatchEvent(new Event("change"));
            setTimeout(() => {
              screenStaysActive.checked = true;
              screenStaysActive.dispatchEvent(new Event("change"));
            }, 150);
          } else {
            screenStaysActive.checked = true;
            screenStaysActive.dispatchEvent(new Event("change"));
          }
        }

        slideshowFavorites = JSON.parse(localStorage.getItem('favoriteSettings') || '[]');
        if (slideshowFavorites.length === 0) {
          alert("No favorites available for slideshow.");
          return;
        }
        slideshowActive = true;
        slideshowIndex = -1;
        nextSlideshow();
        const slideshowButton = document.getElementById('startSlideshow');
        slideshowButton.style.pointerEvents = "none";
        setTimeout(() => { slideshowButton.style.pointerEvents = ""; }, 2000);
        // Hide the control panel and force the mouse cursor to be hidden
        document.getElementById("controlPanel").style.display = "none";
        document.body.style.cursor = "none";
        document.addEventListener('mousemove', mouseMoveCancelHandler);
      }

      function cancelSlideshow() {
        slideshowActive = false;
        if (slideshowTimer) {
          clearTimeout(slideshowTimer);
          slideshowTimer = null;
        }
        document.removeEventListener('mousemove', mouseMoveCancelHandler);
        document.getElementById('startSlideshow').textContent = "SLIDESHOW";
        // Restore the control panel and mouse cursor
        document.getElementById("controlPanel").style.display = "";
        document.body.style.cursor = "";
      }

      const slideshowButton = document.getElementById('startSlideshow');
      slideshowButton.addEventListener('click', () => {
        if (!slideshowActive) {
          startSlideshow();
          slideshowButton.textContent = "SLIDESHOW (Active)";
        } else {
          cancelSlideshow();
          slideshowButton.textContent = "SLIDESHOW";
        }
      });
    });
  </script>

  <!-- New Script: Attach Favorites Roll-down Button Listener -->
  <script>
    const toggleButton = document.getElementById('toggleFavoriteList');
    const favoriteListContainer = document.getElementById('favoriteListContainer');
    if (toggleButton && favoriteListContainer) {
      toggleButton.addEventListener('click', () => {
        favoriteListContainer.classList.toggle('open');
      });
    }
  </script>

<!-- New Script: Export/Import Favorites -->
<script>
  // Export Favorites: Save the favorites from localStorage to a JSON file.
  document.getElementById('exportFavorites').addEventListener('click', function() {
    let favorites = localStorage.getItem('favoriteSettings');
    if (!favorites) {
      document.getElementById('exportStatusText').textContent =
        "No favorites to export (" + new Date().toLocaleTimeString() + ")";
      return;
    }
    let blob = new Blob([favorites], { type: "application/json" });
    let url = URL.createObjectURL(blob);
    let a = document.createElement("a");
    a.href = url;
    // Setting the download attribute forces the browser to prompt for download.
    // The suggested filename is "PuLsE-favs.json" but the user can rename it in the Save As dialog.
    a.download = "PuLsE-favs.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    document.getElementById('exportStatusText').textContent =
      "Exported at " + new Date().toLocaleTimeString();
  });

  // Import Favorites: Read a JSON file and merge the imported favorites with existing ones.
  document.getElementById('importFavorites').addEventListener('click', function() {
    document.getElementById('importFavoritesInput').click();
  });

  document.getElementById('importFavoritesInput').addEventListener('change', function(event) {
    let file = event.target.files[0];
    if (!file) return;
    
    // Accept any file ending with ".json" (case-insensitive)
    if (!file.name.toLowerCase().endsWith(".json")) {
      document.getElementById('importStatusText').textContent =
        "Select a valid .json file (" + new Date().toLocaleTimeString() + ")";
      event.target.value = ""; // Reset the file input.
      return;
    }
    
    let reader = new FileReader();
    reader.onload = function(e) {
      try {
        let importedFavorites = JSON.parse(e.target.result);
        // Check for a valid PuLsE favorites file (must be an array)
        if (!Array.isArray(importedFavorites)) {
          document.getElementById('importStatusText').textContent =
            "Invalid file content (" + new Date().toLocaleTimeString() + ")";
          return;
        }
        let currentFavorites = JSON.parse(localStorage.getItem('favoriteSettings') || '[]');
        // Append the imported favorites to the end.
        let mergedFavorites = currentFavorites.concat(importedFavorites);
        localStorage.setItem('favoriteSettings', JSON.stringify(mergedFavorites));
        updateFavoriteList();
        document.getElementById('importStatusText').textContent =
          "Imported at " + new Date().toLocaleTimeString();
      } catch (err) {
        document.getElementById('importStatusText').textContent =
          "Error reading file (" + new Date().toLocaleTimeString() + ")";
      }
    };
    reader.readAsText(file);
    // Reset the file input so the same file can be re-imported if needed.
    event.target.value = "";
  });
</script>


<!-- New Script: Attach data-target event listeners to category roll-down headers -->
<script> 
// Now only attach the toggle handler to the category headers within #eqModules.
document.querySelectorAll('#eqModules > div > .moduleHeader[data-target]').forEach(header => {
  header.addEventListener('click', function(){
    const targetId = header.getAttribute('data-target');
    const contentDiv = document.getElementById(targetId);
    contentDiv.style.display = (contentDiv.style.display === 'block') ? 'none' : 'block';
  });
});
</script>

</body>
</html>
